name: Advanced DevOps CI/CD

on:
  push:
    branches: [ "main" ]
  workflow_dispatch:

jobs:
  # Part 1: Checking the Code (CI)
  # Making sure everything works and is safe before we do anything else
  ci:
    name: CI - Quality & Security
    runs-on: ubuntu-latest
    permissions:
      actions: read
      contents: read
      security-events: write
    
    steps:
      # Get the code from the repo
      - name: Checkout Code
        uses: actions/checkout@v4

      # Install Bun so we can run our app
      - name: Setup Bun
        uses: oven-sh/setup-bun@v1
        with:
          bun-version: latest

      # Download all the packages we need
      - name: Install Dependencies
        run: bun install --frozen-lockfile

      # Check for messy code (Linting)
      # Keeps the code looking clean so it's actually readable
      - name: Linting
        run: bun run lint

      # Run our tests to make sure I didn't break anything
      # Better to catch bugs now than later!
      - name: Unit Tests
        run: bun test

      # Security: Scanning my own code
      # Making sure I didn't leave any obvious security holes or mistakes
      - name: Initialize CodeQL
        uses: github/codeql-action/init@v3
        with:
          languages: javascript-typescript

      - name: Perform CodeQL Analysis
        uses: github/codeql-action/analyze@v3

      # Security: Scanning the libraries I used
      # Sometimes the packages we download have bugs or vulnerabilities in them
      - name: Run Trivy Vulnerability Scanner (Filesystem)
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          scan-ref: '.'
          format: 'table'
          exit-code: '1' # Fail pipeline if severe vulnerabilities found
          ignore-unfixed: true
          severity: 'CRITICAL,HIGH'

  # Part 2: Shipping the Code (CD)
  # Now that the code is clean, let's turn it into a Docker image
  cd:
    name: CD - Build & Push
    needs: [ci] # Only run if CI passes
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      # Log into Docker Hub so we can upload our final image later
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      # Build the Docker image locally first
      # We need to build it here so we can check it for bugs before we push it
      - name: Build and Export to Docker
        uses: docker/build-push-action@v5
        with:
          context: .
          load: true # Start with local load, don't push yet
          tags: ${{ secrets.DOCKERHUB_USERNAME }}/pdf-to-image:${{ github.sha }}

      # One last security check on the final image
      # Making sure the whole container environment is safe for production
      - name: Run Trivy Vulnerability Scanner (Image)
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ secrets.DOCKERHUB_USERNAME }}/pdf-to-image:${{ github.sha }}
          format: 'table'
          exit-code: '1'
          ignore-unfixed: true
          severity: 'CRITICAL,HIGH'

      # Quick test to see if it actually turns on (Smoke Test)
      # Just making sure it doesn't crash right when it starts up
      - name: Smoke Test
        run: |
          docker run -d -p 3000:3000 --name smoke-test ${{ secrets.DOCKERHUB_USERNAME }}/pdf-to-image:${{ github.sha }}
          sleep 10 # Give it a moment to boot
          curl -f http://localhost:3000/health || (docker logs smoke-test && exit 1)
          docker stop smoke-test

      # Everything looks good! Sending the final version to Docker Hub
      # We only get here if all the checks above passed successfully
      - name: Build and Push
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: |
            ${{ secrets.DOCKERHUB_USERNAME }}/pdf-to-image:latest
            ${{ secrets.DOCKERHUB_USERNAME }}/pdf-to-image:${{ github.sha }}

  # Part 3: Kubernetes Integration Test (Kind)
  # This is the "simpler" way to test K8s without needing a real cloud cluster
  k8s-test:
    name: K8s Test (Kind)
    needs: [cd]
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Create Kind Cluster
        uses: helm/kind-action@v1.9.0

      - name: Load Image to Kind
        run: |
          docker pull ${{ secrets.DOCKERHUB_USERNAME }}/pdf-to-image:${{ github.sha }}
          kind load docker-image ${{ secrets.DOCKERHUB_USERNAME }}/pdf-to-image:${{ github.sha }} --name chart-testing

      - name: Deploy to Kind
        run: |
          # Create dummy secret for testing
          kubectl create secret generic gcs-key --from-literal=gcs-key.json='{"dummy":"data"}'
          
          # Update image in deployment.yaml
          sed -i "s|image:.*|image: ${{ secrets.DOCKERHUB_USERNAME }}/pdf-to-image:${{ github.sha }}|g" k8s/deployment.yaml
          
          # Apply manifests
          kubectl apply -f k8s/deployment.yaml
          kubectl apply -f k8s/service.yaml
          
          # Wait for deployment to be ready
          kubectl rollout status deployment/pdf-to-image --timeout=90s

      - name: Check K8s Resources
        run: |
          kubectl get pods
          kubectl get services
